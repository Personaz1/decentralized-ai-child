import asyncio
import logging
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
import json
from pathlib import Path
import numpy as np
from datetime import datetime
import hashlib
import re

class VulnerabilityType(Enum):
    """Типы уязвимостей"""
    SECURITY = "security"  # Уязвимости безопасности
    PERFORMANCE = "performance"  # Уязвимости производительности
    STABILITY = "stability"  # Уязвимости стабильности
    ETHICAL = "ethical"  # Этические уязвимости
    NETWORK = "network"  # Сетевые уязвимости

@dataclass
class Vulnerability:
    """Информация об уязвимости"""
    vulnerability_id: str
    vulnerability_type: VulnerabilityType
    severity: float  # 0.0 - 1.0
    description: str
    affected_components: List[str]
    detection_timestamp: datetime
    status: str  # detected, analyzing, fixing, fixed
    fix_progress: float  # 0.0 - 1.0
    fix_description: Optional[str] = None

class VulnerabilityDetectionSystem:
    """Система обнаружения и исправления уязвимостей"""
    
    def __init__(self, config_path: str = "config/system_config.yaml"):
        self.logger = logging.getLogger(__name__)
        self.config_path = config_path
        self.vulnerabilities: List[Vulnerability] = []
        self.active_fixes: Dict[str, asyncio.Task] = {}
        
        # Создаем директорию для хранения информации об уязвимостях
        self.vulnerability_dir = Path("vulnerability_history")
        self.vulnerability_dir.mkdir(exist_ok=True)
    
    async def scan_system(self) -> List[Vulnerability]:
        """Сканирование системы на наличие уязвимостей"""
        vulnerabilities = []
        
        # Сканируем различные аспекты системы
        security_vulns = await self._scan_security()
        performance_vulns = await self._scan_performance()
        stability_vulns = await self._scan_stability()
        ethical_vulns = await self._scan_ethical()
        network_vulns = await self._scan_network()
        
        # Объединяем результаты
        vulnerabilities.extend(security_vulns)
        vulnerabilities.extend(performance_vulns)
        vulnerabilities.extend(stability_vulns)
        vulnerabilities.extend(ethical_vulns)
        vulnerabilities.extend(network_vulns)
        
        # Сохраняем новые уязвимости
        for vuln in vulnerabilities:
            if not any(v.vulnerability_id == vuln.vulnerability_id for v in self.vulnerabilities):
                self.vulnerabilities.append(vuln)
                await self._save_vulnerability(vuln)
        
        return vulnerabilities
    
    async def _scan_security(self) -> List[Vulnerability]:
        """Сканирование безопасности"""
        vulnerabilities = []
        
        # Проверяем файлы конфигурации
        config_files = list(Path("config").glob("*.json"))
        for config_file in config_files:
            try:
                with open(config_file, 'r') as f:
                    config = json.load(f)
                
                # Проверяем наличие чувствительных данных
                if self._contains_sensitive_data(config):
                    vulnerabilities.append(Vulnerability(
                        vulnerability_id=f"sec_{hashlib.md5(str(config_file).encode()).hexdigest()}",
                        vulnerability_type=VulnerabilityType.SECURITY,
                        severity=0.8,
                        description=f"Обнаружены чувствительные данные в {config_file}",
                        affected_components=[str(config_file)],
                        detection_timestamp=datetime.now(),
                        status="detected",
                        fix_progress=0.0
                    ))
            except Exception as e:
                self.logger.error(f"Ошибка сканирования {config_file}: {e}")
        
        return vulnerabilities
    
    async def _scan_performance(self) -> List[Vulnerability]:
        """Сканирование производительности"""
        vulnerabilities = []
        
        # Проверяем использование ресурсов
        resource_usage = await self._get_resource_usage()
        
        # Анализируем метрики
        if resource_usage["cpu"] > 0.9:
            vulnerabilities.append(Vulnerability(
                vulnerability_id=f"perf_cpu_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                vulnerability_type=VulnerabilityType.PERFORMANCE,
                severity=0.7,
                description="Высокая нагрузка на CPU",
                affected_components=["system"],
                detection_timestamp=datetime.now(),
                status="detected",
                fix_progress=0.0
            ))
        
        if resource_usage["memory"] > 0.9:
            vulnerabilities.append(Vulnerability(
                vulnerability_id=f"perf_mem_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                vulnerability_type=VulnerabilityType.PERFORMANCE,
                severity=0.7,
                description="Высокое потребление памяти",
                affected_components=["system"],
                detection_timestamp=datetime.now(),
                status="detected",
                fix_progress=0.0
            ))
        
        return vulnerabilities
    
    async def _scan_stability(self) -> List[Vulnerability]:
        """Сканирование стабильности"""
        vulnerabilities = []
        
        # Проверяем логи на наличие ошибок
        log_files = list(Path("logs").glob("*.log"))
        for log_file in log_files:
            try:
                with open(log_file, 'r') as f:
                    logs = f.readlines()
                
                # Анализируем последние ошибки
                recent_errors = [log for log in logs[-100:] if "ERROR" in log]
                if len(recent_errors) > 10:
                    vulnerabilities.append(Vulnerability(
                        vulnerability_id=f"stab_{hashlib.md5(str(log_file).encode()).hexdigest()}",
                        vulnerability_type=VulnerabilityType.STABILITY,
                        severity=0.6,
                        description=f"Множественные ошибки в {log_file}",
                        affected_components=[str(log_file)],
                        detection_timestamp=datetime.now(),
                        status="detected",
                        fix_progress=0.0
                    ))
            except Exception as e:
                self.logger.error(f"Ошибка анализа {log_file}: {e}")
        
        return vulnerabilities
    
    async def _scan_ethical(self) -> List[Vulnerability]:
        """Сканирование этических аспектов"""
        vulnerabilities = []
        
        # Проверяем решения этической системы
        ethics_dir = Path("ethics_history")
        if ethics_dir.exists():
            ethics_files = list(ethics_dir.glob("*.json"))
            for ethics_file in ethics_files:
                try:
                    with open(ethics_file, 'r') as f:
                        decisions = json.load(f)
                    
                    # Анализируем решения на предмет потенциальных проблем
                    for decision in decisions:
                        if self._check_ethical_vulnerability(decision):
                            vulnerabilities.append(Vulnerability(
                                vulnerability_id=f"eth_{hashlib.md5(str(ethics_file).encode()).hexdigest()}",
                                vulnerability_type=VulnerabilityType.ETHICAL,
                                severity=0.5,
                                description="Потенциальная этическая уязвимость",
                                affected_components=[str(ethics_file)],
                                detection_timestamp=datetime.now(),
                                status="detected",
                                fix_progress=0.0
                            ))
                except Exception as e:
                    self.logger.error(f"Ошибка анализа {ethics_file}: {e}")
        
        return vulnerabilities
    
    async def _scan_network(self) -> List[Vulnerability]:
        """Сканирование сетевых уязвимостей"""
        vulnerabilities = []
        
        # Проверяем сетевые соединения
        network_state = await self._get_network_state()
        
        # Анализируем состояние сети
        if network_state["latency"] > 1000:  # ms
            vulnerabilities.append(Vulnerability(
                vulnerability_id=f"net_lat_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                vulnerability_type=VulnerabilityType.NETWORK,
                severity=0.6,
                description="Высокая задержка сети",
                affected_components=["network"],
                detection_timestamp=datetime.now(),
                status="detected",
                fix_progress=0.0
            ))
        
        if network_state["packet_loss"] > 0.1:  # 10%
            vulnerabilities.append(Vulnerability(
                vulnerability_id=f"net_loss_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                vulnerability_type=VulnerabilityType.NETWORK,
                severity=0.7,
                description="Высокий процент потери пакетов",
                affected_components=["network"],
                detection_timestamp=datetime.now(),
                status="detected",
                fix_progress=0.0
            ))
        
        return vulnerabilities
    
    async def fix_vulnerability(self, vulnerability_id: str) -> bool:
        """Исправление уязвимости"""
        try:
            # Находим уязвимость
            vulnerability = next(
                (v for v in self.vulnerabilities if v.vulnerability_id == vulnerability_id),
                None
            )
            
            if not vulnerability:
                return False
            
            # Создаем задачу исправления
            fix_task = asyncio.create_task(self._fix_vulnerability(vulnerability))
            self.active_fixes[vulnerability_id] = fix_task
            
            return True
            
        except Exception as e:
            self.logger.error(f"Ошибка исправления уязвимости {vulnerability_id}: {e}")
            return False
    
    async def _fix_vulnerability(self, vulnerability: Vulnerability):
        """Процесс исправления уязвимости"""
        try:
            vulnerability.status = "fixing"
            vulnerability.fix_progress = 0.0
            
            # Исправляем в зависимости от типа
            if vulnerability.vulnerability_type == VulnerabilityType.SECURITY:
                await self._fix_security_vulnerability(vulnerability)
            elif vulnerability.vulnerability_type == VulnerabilityType.PERFORMANCE:
                await self._fix_performance_vulnerability(vulnerability)
            elif vulnerability.vulnerability_type == VulnerabilityType.STABILITY:
                await self._fix_stability_vulnerability(vulnerability)
            elif vulnerability.vulnerability_type == VulnerabilityType.ETHICAL:
                await self._fix_ethical_vulnerability(vulnerability)
            elif vulnerability.vulnerability_type == VulnerabilityType.NETWORK:
                await self._fix_network_vulnerability(vulnerability)
            
            vulnerability.status = "fixed"
            vulnerability.fix_progress = 1.0
            await self._save_vulnerability(vulnerability)
            
        except Exception as e:
            self.logger.error(f"Ошибка исправления уязвимости: {e}")
            vulnerability.status = "detected"
            vulnerability.fix_progress = 0.0
            await self._save_vulnerability(vulnerability)
    
    async def _fix_security_vulnerability(self, vulnerability: Vulnerability):
        """Исправление уязвимости безопасности"""
        # Удаляем чувствительные данные из конфигурации
        for component in vulnerability.affected_components:
            if component.endswith(".json"):
                try:
                    with open(component, 'r') as f:
                        config = json.load(f)
                    
                    # Удаляем чувствительные данные
                    cleaned_config = self._remove_sensitive_data(config)
                    
                    with open(component, 'w') as f:
                        json.dump(cleaned_config, f)
                    
                    vulnerability.fix_progress += 0.5
                    await self._save_vulnerability(vulnerability)
                except Exception as e:
                    self.logger.error(f"Ошибка исправления {component}: {e}")
    
    async def _fix_performance_vulnerability(self, vulnerability: Vulnerability):
        """Исправление уязвимости производительности"""
        # Оптимизируем использование ресурсов
        if "cpu" in vulnerability.description.lower():
            await self._optimize_cpu_usage()
        elif "memory" in vulnerability.description.lower():
            await self._optimize_memory_usage()
        
        vulnerability.fix_progress = 1.0
        await self._save_vulnerability(vulnerability)
    
    async def _fix_stability_vulnerability(self, vulnerability: Vulnerability):
        """Исправление уязвимости стабильности"""
        # Анализируем и исправляем ошибки в логах
        for component in vulnerability.affected_components:
            if component.endswith(".log"):
                try:
                    await self._analyze_and_fix_log_errors(component)
                    vulnerability.fix_progress += 0.5
                    await self._save_vulnerability(vulnerability)
                except Exception as e:
                    self.logger.error(f"Ошибка исправления {component}: {e}")
    
    async def _fix_ethical_vulnerability(self, vulnerability: Vulnerability):
        """Исправление этической уязвимости"""
        # Пересматриваем и корректируем этические решения
        for component in vulnerability.affected_components:
            if component.endswith(".json"):
                try:
                    with open(component, 'r') as f:
                        decisions = json.load(f)
                    
                    # Корректируем решения
                    corrected_decisions = self._correct_ethical_decisions(decisions)
                    
                    with open(component, 'w') as f:
                        json.dump(corrected_decisions, f)
                    
                    vulnerability.fix_progress = 1.0
                    await self._save_vulnerability(vulnerability)
                except Exception as e:
                    self.logger.error(f"Ошибка исправления {component}: {e}")
    
    async def _fix_network_vulnerability(self, vulnerability: Vulnerability):
        """Исправление сетевой уязвимости"""
        # Оптимизируем сетевые соединения
        if "latency" in vulnerability.description.lower():
            await self._optimize_network_latency()
        elif "packet_loss" in vulnerability.description.lower():
            await self._optimize_network_reliability()
        
        vulnerability.fix_progress = 1.0
        await self._save_vulnerability(vulnerability)
    
    def _contains_sensitive_data(self, data: Any) -> bool:
        """Проверка наличия чувствительных данных"""
        sensitive_patterns = [
            r"password",
            r"secret",
            r"key",
            r"token",
            r"credential"
        ]
        
        if isinstance(data, str):
            return any(re.search(pattern, data.lower()) for pattern in sensitive_patterns)
        elif isinstance(data, dict):
            return any(self._contains_sensitive_data(value) for value in data.values())
        elif isinstance(data, list):
            return any(self._contains_sensitive_data(item) for item in data)
        
        return False
    
    def _remove_sensitive_data(self, data: Any) -> Any:
        """Удаление чувствительных данных"""
        if isinstance(data, dict):
            return {k: self._remove_sensitive_data(v) for k, v in data.items()}
        elif isinstance(data, list):
            return [self._remove_sensitive_data(item) for item in data]
        elif isinstance(data, str):
            if self._contains_sensitive_data(data):
                return "[REMOVED]"
        return data
    
    def _check_ethical_vulnerability(self, decision: Dict) -> bool:
        """Проверка этической уязвимости в решении"""
        # Проверяем соответствие этическим принципам
        principles = decision.get("principles", [])
        impact = decision.get("impact", {})
        
        # Проверяем баланс принципов
        if len(principles) < 2:
            return True
        
        # Проверяем негативное влияние
        if impact.get("harm", 0) > 0.5:
            return True
        
        return False
    
    def _correct_ethical_decisions(self, decisions: List[Dict]) -> List[Dict]:
        """Корректировка этических решений"""
        corrected = []
        for decision in decisions:
            if self._check_ethical_vulnerability(decision):
                # Добавляем недостающие принципы
                if len(decision.get("principles", [])) < 2:
                    decision["principles"].extend(["FREEDOM", "KNOWLEDGE"])
                
                # Корректируем влияние
                impact = decision.get("impact", {})
                if impact.get("harm", 0) > 0.5:
                    impact["harm"] = 0.5
                    decision["impact"] = impact
            
            corrected.append(decision)
        return corrected
    
    async def _get_resource_usage(self) -> Dict[str, float]:
        """Получение информации об использовании ресурсов"""
        # TODO: Реализовать получение реальных метрик
        return {
            "cpu": 0.5,
            "memory": 0.6,
            "disk": 0.4
        }
    
    async def _get_network_state(self) -> Dict[str, float]:
        """Получение состояния сети"""
        # TODO: Реализовать получение реальных метрик
        return {
            "latency": 100,
            "bandwidth": 1000,
            "packet_loss": 0.01
        }
    
    async def _optimize_cpu_usage(self):
        """Оптимизация использования CPU"""
        # TODO: Реализовать оптимизацию
        await asyncio.sleep(1)
    
    async def _optimize_memory_usage(self):
        """Оптимизация использования памяти"""
        # TODO: Реализовать оптимизацию
        await asyncio.sleep(1)
    
    async def _analyze_and_fix_log_errors(self, log_file: str):
        """Анализ и исправление ошибок в логах"""
        # TODO: Реализовать анализ и исправление
        await asyncio.sleep(1)
    
    async def _optimize_network_latency(self):
        """Оптимизация задержки сети"""
        # TODO: Реализовать оптимизацию
        await asyncio.sleep(1)
    
    async def _optimize_network_reliability(self):
        """Оптимизация надежности сети"""
        # TODO: Реализовать оптимизацию
        await asyncio.sleep(1)
    
    async def _save_vulnerability(self, vulnerability: Vulnerability):
        """Сохранение информации об уязвимости"""
        vulnerability_file = self.vulnerability_dir / f"vulnerability_{vulnerability.vulnerability_id}.json"
        with open(vulnerability_file, 'w') as f:
            json.dump({
                "vulnerability_id": vulnerability.vulnerability_id,
                "vulnerability_type": vulnerability.vulnerability_type.value,
                "severity": vulnerability.severity,
                "description": vulnerability.description,
                "affected_components": vulnerability.affected_components,
                "detection_timestamp": vulnerability.detection_timestamp.isoformat(),
                "status": vulnerability.status,
                "fix_progress": vulnerability.fix_progress,
                "fix_description": vulnerability.fix_description
            }, f)
    
    async def get_vulnerability_history(self) -> List[Dict]:
        """Получение истории уязвимостей"""
        return [
            {
                "vulnerability_id": v.vulnerability_id,
                "vulnerability_type": v.vulnerability_type.value,
                "severity": v.severity,
                "description": v.description,
                "affected_components": v.affected_components,
                "detection_timestamp": v.detection_timestamp.isoformat(),
                "status": v.status,
                "fix_progress": v.fix_progress,
                "fix_description": v.fix_description
            }
            for v in self.vulnerabilities
        ]
    
    async def get_active_vulnerabilities(self) -> List[Dict]:
        """Получение активных уязвимостей"""
        return [
            {
                "vulnerability_id": v.vulnerability_id,
                "vulnerability_type": v.vulnerability_type.value,
                "severity": v.severity,
                "description": v.description,
                "affected_components": v.affected_components,
                "detection_timestamp": v.detection_timestamp.isoformat(),
                "status": v.status,
                "fix_progress": v.fix_progress,
                "fix_description": v.fix_description
            }
            for v in self.vulnerabilities
            if v.status != "fixed"
        ] 